"""
ImageSearchHandler: Specialized Image Search Engine for Generated Images
========================================================================

This class provides comprehensive search capabilities for AI-generated images stored in a vector
database. It supports multiple search modalities including metadata-based filtering, semantic
similarity search, and content-based retrieval with integrated access control.

CORE ARCHITECTURE:
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           ImageSearchHandler                                    │
├─────────────────────────────────────────────────────────────────────────────────┤
│ Dependencies:                                                                   │
│ • ChromaManager: Vector DB operations for image metadata & embeddings           │
│ • ImageEmbedder: Converts images/text to vector embeddings (optional)           │
│ • AccessControlManager: User permission filtering (optional)                    │
│ • Analytics: Performance monitoring and logging (optional)                      │
└─────────────────────────────────────────────────────────────────────────────────┘

SEARCH DISPATCH WORKFLOW:
┌─────────────┐    ┌──────────────┐    ┌─────────────────┐    ┌──────────────┐
│   Search    │    │  Parameter   │    │   Search Type   │    │   Handler    │
│   Request   │───▶│  Extraction  │───▶│  Identification │───▶│  Dispatch    │
│             │    │              │    │                 │    │              │
└─────────────┘    └──────────────┘    └─────────────────┘    └──────────────┘
                                                │
                ┌───────────────────────────────┼───────────────────────────────┐
                │                               ▼                               │
     ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐  ┌───────────────┐
     │   Metadata       │  │   Vector         │  │   Content        │  │   Temporal    │
     │   Searches       │  │   Similarity     │  │   Analysis       │  │   Filtering   │
     │                  │  │                  │  │                  │  │               │
     └──────────────────┘  └──────────────────┘  └──────────────────┘  └───────────────┘
             │                       │                       │                   │
             ▼                       ▼                       ▼                   ▼
     ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐  ┌───────────────┐
     │ • model_id       │  │ • similarity     │  │ • content        │  │ • date        │
     │ • epoch          │  │ • text_query     │  │ • tag            │  │ • color       │
     │ • highest_epoch  │  │ • image_query    │  │ • visual_search  │  │ • timerange   │
     └──────────────────┘  └──────────────────┘  └──────────────────┘  └───────────────┘
             │                       │                       │                   │
             └───────────────────────┼───────────────────────────────────────────┘
                                     ▼
                           ┌──────────────────┐
                           │  Access Control  │
                           │   Filtering &    │
                           │ Result Assembly  │
                           └──────────────────┘
                                     │
                                     ▼
                           ┌──────────────────┐
                           │   Performance    │
                           │   Monitoring &   │
                           │   Response       │
                           └──────────────────┘

SEARCH TYPES AND METHODS:

1. MODEL-BASED SEARCHES:
   a) find_images_by_model_id(model_id, user_id):
      - Retrieves all images generated by a specific model
      - Applies access control filtering
      - Returns ranked results with similarity scores

   b) find_images_by_epoch(model_id, epoch, user_id):
      - Finds images from specific training epochs
      - Useful for tracking model evolution over training
      - Supports epoch filtering (None = all epochs)

   c) find_highest_epoch_images(model_id, user_id):
      - Retrieves images from the most recent training epoch
      - Automatically determines highest epoch number
      - Returns only the latest generation results

2. CONTENT-BASED SEARCHES:
   a) find_images_by_content(content_filter, user_id):
      - Searches based on structured image content metadata
      - Supports nested field queries (e.g., "subject_details.species")
      - Maps to image_content.* fields in the database

      Example content_filter:
      {
          "subject_type": "animal",
          "subject_details.species": "cat",
          "scene_type": "outdoor",
          "style": "photorealistic"
      }

   b) find_images_by_tag(tags, require_all, user_id):
      - Tag-based filtering with AND/OR logic
      - require_all=True: image must have ALL specified tags
      - require_all=False: image must have ANY specified tag
      - Tags stored in image_content.tags array

   c) find_images_by_color(colors, user_id):
      - Color-based image filtering
      - Supports hex codes or color names
      - Matches against image_content.colors array
      - Case-insensitive matching

3. TEMPORAL SEARCHES:
   a) find_images_by_date(date_filter, user_id):
      - Date-based filtering with flexible criteria
      - Supports created_year, created_month, last_modified_*
      - Maps to dates.* fields in metadata

      Example date_filter:
      {
          "created_year": "2025",
          "created_month": "04"
      }

4. VECTOR SIMILARITY SEARCH:
   a) search_images_by_similarity(query_image, query_text, limit, content_filter, user_id):
      - Semantic similarity using vector embeddings
      - Supports both image and text queries
      - Combines similarity search with metadata filtering
      - Requires ImageEmbedder component for functionality
      - Returns results ranked by similarity score

SEARCH DISPATCHER PATTERN:

The _handle_image_search() method implements a dispatcher pattern that routes requests
to specialized handlers based on search_type parameter:

Search Type Mapping:
{
    "model_id": _search_by_model_id,
    "epoch": _search_by_epoch,
    "highest_epoch": _search_by_highest_epoch,
    "content": _search_by_content,
    "tag": _search_by_tag,
    "date": _search_by_date,
    "color": _search_by_color,
    "similarity": _search_by_similarity
}

Each handler method validates required parameters and delegates to the appropriate
specialized search method.

DATA STRUCTURES:

Image Metadata Structure:
{
    "id": "img_123_epoch_5",
    "metadata": {
        "model_id": "model_123",
        "epoch": 5,
        "image_content": {
            "subject_type": "animal",
            "subject_details": {
                "species": "cat",
                "breed": "tabby"
            },
            "scene_type": "indoor",
            "style": "photorealistic",
            "tags": ["cat", "indoor", "realistic", "animal"],
            "colors": ["#8B4513", "#FFD700", "#228B22"]
        },
        "dates": {
            "created_year": "2025",
            "created_month": "01",
            "last_modified_year": "2025",
            "last_modified_month": "01"
        }
    }
}

Standard Response Format:
{
    "success": True,
    "type": "image_similarity_search",
    "items": [
        {
            "id": "img_123_epoch_5",
            "metadata": {...},
            "similarity": 0.87,
            "rank": 1
        }
    ],
    "total_found": 25,
    "performance": {
        "total_time_ms": 145
    }
}

ACCESS CONTROL INTEGRATION:

- Consistent access control checking across all search methods
- Integration with AccessControlManager for user-based filtering
- Two-level filtering approach:
  1. Database-level: Include access filters in query WHERE clauses
  2. Application-level: Post-filter results using check_access()

Access Control Flow:
1. Extract user_id from request parameters
2. Generate access_filter using AccessControlManager
3. Combine with search criteria using $and operator
4. Apply to database query OR post-filter results
5. Ensure only authorized images are returned

PERFORMANCE OPTIMIZATIONS:

1. Lazy Access Control:
   - Only apply access control when user_id is provided
   - Skip expensive permission checks for public queries

2. Efficient Query Patterns:
   - Use chroma_manager.get() for metadata-only queries
   - Use chroma_manager.search() only when similarity ranking needed
   - Minimize included fields (metadatas, documents, distances)

3. Result Limit Enforcement:
   - Apply limits at database level when possible
   - Post-filter limits for complex queries
   - Early termination for large result sets

4. Analytics Integration:
   - Optional performance monitoring
   - Query timing and metrics collection
   - Error tracking and debugging support

ERROR HANDLING:

- Comprehensive exception handling with structured error responses
- Graceful degradation when optional components unavailable
- Detailed error logging with context preservation
- Consistent error response format across all methods

Example Error Response:
{
    "success": False,
    "error": "Image embedder is required for similarity search but not provided",
    "type": "image_similarity_search",
    "items": [],
    "total_found": 0,
    "performance": {
        "total_time_ms": 12
    }
}

EXTENSIBILITY:

The class is designed for easy extension:
- New search types can be added by implementing handler methods
- Additional metadata fields supported through flexible filtering
- Pluggable components (embedder, access control, analytics)
- Consistent interfaces for all search operations

This architecture enables sophisticated image search capabilities while maintaining
a clean separation of concerns and consistent user experience across all search modalities.
"""
import logging
import time
from typing import Dict, List, Any, Optional


class ImageSearchHandler:
    """
    A class to handle image search and query functionality.
    This separates the search logic from the image processing logic.
    """

    def __init__(self, chroma_manager, image_embedder=None, access_control_manager=None, analytics=None):
        """
        Initialize the ImageSearchManager with required dependencies.

        Args:
            chroma_manager: Manager for Chroma vector database interactions
            image_embedder: Optional component for generating image embeddings
            access_control_manager: Optional manager for access control
            analytics: Optional analytics collector
        """
        self.chroma_manager = chroma_manager
        self.image_embedder = image_embedder
        self.access_control_manager = access_control_manager
        self.analytics = analytics
        self.logger = logging.getLogger(__name__)

    async def handle_image_search(self, query: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """
        Handle an image search query by delegating to the ImageSearchManager.

        Args:
            query: The processed query text
            parameters: Dictionary of extracted parameters

        Returns:
            Dictionary containing search results for image_processing
        """
        self.logger.debug(f"Delegating image search to ImageSearchManager: {query}")
        start_time = time.time()

        try:
            # Delegate to the image search manager
            results = await self._handle_image_search(query, parameters)

            # Add performance metrics if not already included
            if 'performance' not in results:
                results['performance'] = {}

            results['performance']['total_time_ms'] = (time.time() - start_time) * 1000

            # Log performance metrics if analytics available
            if self.analytics and 'query_id' in parameters:
                self.analytics.log_performance_metrics(
                    query_id=parameters['query_id'],
                    total_time_ms=int((time.time() - start_time) * 1000)
                )

            return results

        except Exception as e:
            self.logger.error(f"Error in image search: {e}", exc_info=True)

            # Return a properly structured error response
            return {
                'success': False,
                'error': str(e),
                'type': 'image_search',
                'items': [],
                'total_found': 0,
                'performance': {
                    'total_time_ms': (time.time() - start_time) * 1000
                }
            }

    async def find_images_by_model_id(self, model_id: str, user_id: Optional[str] = None):
        """Find all image_processing generated by a specific model.

        Args:
            model_id: The model ID to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing created by the specified model
        """
        # Build metadata filter
        metadata_filter = {"model_id": model_id}

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database
        search_results = await self.chroma_manager.search(
            collection_name="generated_images",
            query="",
            where=metadata_filter if metadata_filter else None,
            include=["metadatas", "documents", "distances"]
        )

        # Process results
        results = []
        for idx, item in enumerate(search_results.get("results", [])):
            results.append({
                "id": item.get("id"),
                "metadata": item.get("metadata", {}),
                "similarity": 1.0 - (item.get("distance", 0) / 2.0),  # Convert distance to similarity score
                "rank": idx + 1
            })

        return results

    async def find_images_by_epoch(self, model_id: str, epoch: Optional[int] = None, user_id: Optional[str] = None):
        """Find image_processing by model ID and optionally filter by epoch.

        Args:
            model_id: The model ID to search for
            epoch: Optional epoch to filter by. If None, returns all epochs
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing matching the criteria
        """
        # Build metadata filter
        metadata_filter = {"model_id": model_id}
        if epoch is not None:
            metadata_filter["epoch"] = epoch

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database - using get() instead of query_by_metadata()
        query_results = await self.chroma_manager.get(
            collection_name="generated_images",
            where=metadata_filter,
            include=["metadatas", "documents"]
        )

        return query_results.get("results", [])

    async def find_highest_epoch_images(self, model_id: str, user_id: Optional[str] = None):
        """Find image_processing from the highest epoch for a specific model.

        Args:
            model_id: The model ID to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing from the highest epoch
        """
        # First, get all image_processing for this model
        all_images = await self.find_images_by_model_id(model_id, user_id)

        # Find the highest epoch
        highest_epoch = -1
        for image in all_images:
            epoch = image.get("metadata", {}).get("epoch")
            if epoch is not None and isinstance(epoch, int) and epoch > highest_epoch:
                highest_epoch = epoch

        # If no valid epochs found
        if highest_epoch == -1:
            return []

        # Filter to only include image_processing from the highest epoch
        highest_epoch_images = [
            image for image in all_images
            if image.get("metadata", {}).get("epoch") == highest_epoch
        ]

        return highest_epoch_images

    async def find_images_by_content(self, content_filter: Dict[str, Any], user_id: Optional[str] = None):
        """Find image_processing based on their content metadata.

        Args:
            content_filter: Dictionary with content filter criteria
                Example: {
                    "subject_type": "animal",
                    "subject_details.species": "cat",
                    "scene_type": "outdoor"
                }
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing matching the criteria
        """
        # Build metadata filter for content fields
        metadata_filter = {}
        for key, value in content_filter.items():
            if "." in key:  # Handle nested fields like subject_details.species
                parent, child = key.split(".", 1)
                metadata_filter[f"image_content.{parent}.{child}"] = value
            else:
                metadata_filter[f"image_content.{key}"] = value

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database - using get() instead of query_by_metadata()
        query_results = await self.chroma_manager.get(
            collection_name="generated_images",
            where=metadata_filter,
            include=["metadatas", "documents"]
        )

        return query_results.get("results", [])

    async def find_images_by_tag(
            self,
            tags: List[str],
            require_all: bool = False,
            user_id: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Find image_processing that have specific tags.

        Args:
            tags: List of tags to search for
            require_all: If True, image_processing must have all tags. If False, having any tag is sufficient
            user_id: Optional user ID for access control

        Returns:
            list: A list of document dicts for image_processing matching the criteria
        """
        # 1) Fetch all images
        all_images_result = await self.chroma_manager.get(
            collection_name="generated_images",
            user_id=user_id,
            include=["metadatas", "documents"]
        )
        all_images = all_images_result.get("results", [])

        # 2) Filter by access control and tag matching
        matching_images = []
        for image in all_images:
            if not self._is_image_accessible(image, user_id):
                continue
            if self._matches_tags(image, tags, require_all):
                matching_images.append(image)

        return matching_images

    def _is_image_accessible(
            self,
            image: Dict[str, Any],
            user_id: Optional[str]
    ) -> bool:
        """
        Return True if the image passes access control (or if no access control is needed).
        """
        if not self.access_control_manager or not user_id:
            return True

        return self.access_control_manager.check_access(
            {"metadata": image.get("metadata", {})},
            user_id,
            "view"
        )

    @staticmethod
    def _matches_tags(
            image: Dict[str, Any],
            tags: List[str],
            require_all: bool
    ) -> bool:
        """
        Return True if `image` contains all (when require_all=True) or any (when False) of the specified tags.
        """
        image_tags = image.get("metadata", {}).get("image_content", {}).get("tags", [])
        if require_all:
            return all(tag in image_tags for tag in tags)
        return any(tag in image_tags for tag in tags)

    async def find_images_by_date(self, date_filter: Dict[str, str], user_id: Optional[str] = None):
        """Find image_processing based on their creation or modification dates.

        Args:
            date_filter: Dictionary with date filter criteria
                Example: {
                    "created_year": "2025",
                    "created_month": "04"
                }
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing matching the criteria
        """
        # Map of potential date filter fields to their actual field paths
        date_field_mappings = {
            # Created date fields
            "created_year": "dates.created_year",
            "created_month": "dates.created_month",

            # Last modified date fields
            "last_modified_year": "dates.last_modified_year",
            "last_modified_month": "dates.last_modified_month"
        }

        # Build metadata filter for date fields
        metadata_filter = {}
        for key, value in date_filter.items():
            if key in date_field_mappings:
                metadata_filter[date_field_mappings[key]] = value
            else:
                # For any other fields, use direct mapping
                metadata_filter[f"dates.{key}"] = value

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database - using get() instead of query_by_metadata()
        query_results = await self.chroma_manager.get(
            collection_name="generated_images",
            where=metadata_filter,
            include=["metadatas", "documents"]
        )

        return query_results.get("results", [])

    async def find_images_by_color(self, colors: List[str], user_id: Optional[str] = None):
        """Find image_processing that contain specific colors.

        Args:
            colors: List of color hex codes or color names to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for image_processing with the specified colors
        """
        # Query all image_processing - using get() instead of query_all()
        all_images_result = await self.chroma_manager.get(
            collection_name="generated_images",
            user_id=user_id,
            include=["metadatas", "documents"]
        )

        all_images = all_images_result.get("results", [])

        # Filter image_processing based on colors
        matching_images = []
        for image in all_images:
            # Apply access control check
            if self.access_control_manager and user_id:
                if not self.access_control_manager.check_access({'metadata': image.get('metadata', {})}, user_id,
                                                                "view"):
                    continue

            image_colors = image.get("metadata", {}).get("image_content", {}).get("colors", [])

            # Match if any of the specified colors are in the image colors
            if any(color.lower() in [ic.lower() for ic in image_colors] for color in colors):
                matching_images.append(image)

        return matching_images

    async def search_images_by_similarity(
            self,
            query_image=None,
            query_text=None,
            limit=10,
            content_filter=None,
            user_id=None
    ):
        """
        Search for image_processing based on visual or text similarity.

        Args:
            query_image: Optional image data or path to use as a query
            query_text: Optional text to use as a query
            limit: Maximum number of results to return
            content_filter: Optional content filters to apply
            user_id: Optional user ID for access control

        Returns:
            list: A list of image documents matching the query
        """
        if not self.image_embedder:
            raise ValueError(
                "Image embedder is required for similarity search but not provided"
            )

        # 1) Build the combined filter (content + access control)
        filter_query = self._build_image_similarity_filter(content_filter, user_id)

        # 2) Execute the search
        search_results = await self.chroma_manager.search(
            collection_name="generated_images",
            query=query_text if query_text else query_image,
            where=filter_query if filter_query else None,
            limit=limit,
            include=["metadatas", "documents", "distances"]
        )

        # 3) Format and return the results
        return self._format_similarity_results(search_results)

    def _build_image_similarity_filter(
            self,
            content_filter: Optional[Dict[str, Any]],
            user_id: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """
        Construct a Mongo-DSL style filter that combines:
          - content_filter (mapping over 'image_content' fields), and
          - an access control filter (if user_id is provided).

        Returns:
            A single combined filter dict, or None if no filters apply.
        """
        filter_query: Dict[str, Any] = {}

        # Add content_filter fields under "image_content.*"
        if content_filter:
            for key, value in content_filter.items():
                if "." in key:
                    parent, child = key.split(".", 1)
                    filter_query[f"image_content.{parent}.{child}"] = value
                else:
                    filter_query[f"image_content.{key}"] = value

        # Add access control filter if present
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                if filter_query:
                    return {"$and": [filter_query, access_filter]}
                return access_filter

        return filter_query or None

    def _format_similarity_results(
            self,
            search_results: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Given raw search_results from chroma_manager.search, extract and convert
        each hit into a dict with:
          - 'id'
          - 'metadata'
          - 'similarity' (1.0 - distance/2.0)
          - 'rank' (1-based index)
        """
        formatted: List[Dict[str, Any]] = []
        for idx, item in enumerate(search_results.get("results", [])):
            distance = item.get("distance", 0)
            formatted.append({
                "id": item.get("id"),
                "metadata": item.get("metadata", {}),
                "similarity": 1.0 - (distance / 2.0),
                "rank": idx + 1
            })
        return formatted

    async def _handle_image_search(self, query=None, parameters=None):
        """
        Handle various types of image searches based on the provided parameters.
        This is a high-level method that can be used from the SearchDispatcher.

        Args:
            query: The search query (text or image)
            parameters: Dictionary of parameters controlling the search

        Returns:
            Dictionary containing search results
        """
        if parameters is None:
            parameters = {}

        search_type = parameters.get("search_type", "text")
        user_id = parameters.get("user_id")
        limit = parameters.get("limit", 10)

        # Map each search_type to its handler coroutine method
        handlers = {
            "model_id": self._search_by_model_id,
            "epoch": self._search_by_epoch,
            "highest_epoch": self._search_by_highest_epoch,
            "content": self._search_by_content,
            "tag": self._search_by_tag,
            "date": self._search_by_date,
            "color": self._search_by_color,
            "similarity": self._search_by_similarity,
        }

        try:
            if search_type not in handlers:
                raise ValueError(f"Unknown search type: {search_type}")

            # Call the appropriate handler
            results = await handlers[search_type](query, parameters, user_id, limit)

            # Enforce the result limit if necessary
            if limit and isinstance(results, list) and len(results) > limit:
                results = results[:limit]

            return {
                "success": True,
                "type": f"image_{search_type}_search",
                "items": results,
                "total_found": len(results),
            }

        except Exception as e:
            self.logger.error(f"Error in image search: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "type": f"image_{search_type}_search",
                "items": [],
                "total_found": 0,
            }

    async def _search_by_model_id(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "model_id".
        Requires parameters["filters"]["model_id"].
        """
        model_id = parameters.get("filters", {}).get("model_id")
        if not model_id:
            raise ValueError("model_id is required for model_id search")
        return await self.find_images_by_model_id(model_id, user_id)

    async def _search_by_epoch(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "epoch".
        Requires parameters["filters"]["model_id"] and parameters["epoch"].
        """
        filters = parameters.get("filters", {})
        model_id = filters.get("model_id")
        epoch = parameters.get("epoch")
        if not model_id:
            raise ValueError("model_id is required for epoch search")
        return await self.find_images_by_epoch(model_id, epoch, user_id)

    async def _search_by_highest_epoch(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "highest_epoch".
        Requires parameters["filters"]["model_id"].
        """
        model_id = parameters.get("filters", {}).get("model_id")
        if not model_id:
            raise ValueError("model_id is required for highest_epoch search")
        return await self.find_highest_epoch_images(model_id, user_id)

    async def _search_by_content(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "content".
        Requires parameters["content_filter"].
        """
        content_filter = parameters.get("content_filter", {})
        if not content_filter:
            raise ValueError("content_filter is required for content search")
        return await self.find_images_by_content(content_filter, user_id)

    async def _search_by_tag(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "tag".
        Requires parameters["tags"].
        """
        tags = parameters.get("tags", [])
        require_all = parameters.get("require_all", False)
        if not tags:
            raise ValueError("tags are required for tag search")
        return await self.find_images_by_tag(tags, require_all, user_id)

    async def _search_by_date(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "date".
        Requires parameters["date_filter"].
        """
        date_filter = parameters.get("date_filter", {})
        if not date_filter:
            raise ValueError("date_filter is required for date search")
        return await self.find_images_by_date(date_filter, user_id)

    async def _search_by_color(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "color".
        Requires parameters["colors"].
        """
        colors = parameters.get("colors", [])
        if not colors:
            raise ValueError("colors are required for color search")
        return await self.find_images_by_color(colors, user_id)

    async def _search_by_similarity(self, query, parameters, user_id, limit):
        """
        Handler for search_type == "similarity".
        Requires either parameters["query_image"] or parameters["query_text"].
        """
        query_image = parameters.get("query_image")
        query_text = parameters.get("query_text", query)
        content_filter = parameters.get("content_filter")

        if not query_image and not query_text:
            raise ValueError(
                "Either query_image or query_text is required for similarity search"
            )

        return await self.search_images_by_similarity(
            query_image=query_image,
            query_text=query_text,
            limit=limit,
            content_filter=content_filter,
            user_id=user_id,
        )
