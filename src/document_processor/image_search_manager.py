import logging
from typing import Dict, List, Any, Optional


class ImageSearchManager:
    """
    A class to handle image search and query functionality.
    This separates the search logic from the image processing logic.
    """

    def __init__(self, chroma_manager, image_embedder=None, access_control_manager=None, analytics=None):
        """
        Initialize the ImageSearchManager with required dependencies.

        Args:
            chroma_manager: Manager for Chroma vector database interactions
            image_embedder: Optional component for generating image embeddings
            access_control_manager: Optional manager for access control
            analytics: Optional analytics collector
        """
        self.chroma_manager = chroma_manager
        self.image_embedder = image_embedder
        self.access_control_manager = access_control_manager
        self.analytics = analytics
        self.logger = logging.getLogger(__name__)

    async def find_images_by_model_id(self, model_id: str, user_id: Optional[str] = None):
        """Find all images generated by a specific model.

        Args:
            model_id: The model ID to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images created by the specified model
        """
        # Build metadata filter
        metadata_filter = {"model_id": model_id}

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database
        query_results = await self.chroma_manager.query_by_metadata(
            collection_name="generated_images",
            metadata_filter=metadata_filter
        )

        return query_results

    async def find_images_by_epoch(self, model_id: str, epoch: Optional[int] = None, user_id: Optional[str] = None):
        """Find images by model ID and optionally filter by epoch.

        Args:
            model_id: The model ID to search for
            epoch: Optional epoch to filter by. If None, returns all epochs
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images matching the criteria
        """
        # Build metadata filter
        metadata_filter = {"model_id": model_id}
        if epoch is not None:
            metadata_filter["epoch"] = epoch

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database
        query_results = await self.chroma_manager.query_by_metadata(
            collection_name="generated_images",
            metadata_filter=metadata_filter
        )

        return query_results

    async def find_highest_epoch_images(self, model_id: str, user_id: Optional[str] = None):
        """Find images from the highest epoch for a specific model.

        Args:
            model_id: The model ID to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images from the highest epoch
        """
        # First, get all images for this model
        all_images = await self.find_images_by_model_id(model_id, user_id)

        # Find the highest epoch
        highest_epoch = -1
        for image in all_images:
            epoch = image.get("metadata", {}).get("epoch")
            if epoch is not None and isinstance(epoch, int) and epoch > highest_epoch:
                highest_epoch = epoch

        # If no valid epochs found
        if highest_epoch == -1:
            return []

        # Filter to only include images from the highest epoch
        highest_epoch_images = [
            image for image in all_images
            if image.get("metadata", {}).get("epoch") == highest_epoch
        ]

        return highest_epoch_images

    async def find_images_by_content(self, content_filter: Dict[str, Any], user_id: Optional[str] = None):
        """Find images based on their content metadata.

        Args:
            content_filter: Dictionary with content filter criteria
                Example: {
                    "subject_type": "animal",
                    "subject_details.species": "cat",
                    "scene_type": "outdoor"
                }
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images matching the criteria
        """
        # Build metadata filter for content fields
        metadata_filter = {}
        for key, value in content_filter.items():
            if "." in key:  # Handle nested fields like subject_details.species
                parent, child = key.split(".", 1)
                metadata_filter[f"image_content.{parent}.{child}"] = value
            else:
                metadata_filter[f"image_content.{key}"] = value

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database
        query_results = await self.chroma_manager.query_by_metadata(
            collection_name="generated_images",
            metadata_filter=metadata_filter
        )

        return query_results

    async def find_images_by_tag(self, tags: List[str], require_all: bool = False, user_id: Optional[str] = None):
        """Find images that have specific tags.

        Args:
            tags: List of tags to search for
            require_all: If True, images must have all tags. If False, having any tag is sufficient
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images matching the criteria
        """
        # Query all images (we'll filter them manually since tag is an array)
        all_images = await self.chroma_manager.query_all(
            collection_name="generated_images",
            user_id=user_id
        )

        # Filter images based on tags
        matching_images = []
        for image in all_images:
            # Apply access control check
            if self.access_control_manager and user_id:
                if not self.access_control_manager.check_access({'metadata': image.get('metadata', {})}, user_id,
                                                                "view"):
                    continue

            image_tags = image.get("metadata", {}).get("image_content", {}).get("tags", [])

            if require_all:
                # Image must have all specified tags
                if all(tag in image_tags for tag in tags):
                    matching_images.append(image)
            else:
                # Image must have at least one of the specified tags
                if any(tag in image_tags for tag in tags):
                    matching_images.append(image)

        return matching_images

    async def find_images_by_date(self, date_filter: Dict[str, str], user_id: Optional[str] = None):
        """Find images based on their creation or modification dates.

        Args:
            date_filter: Dictionary with date filter criteria
                Example: {
                    "created_year": "2025",
                    "created_month": "04"
                }
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images matching the criteria
        """
        # Map of potential date filter fields to their actual field paths
        date_field_mappings = {
            # Created date fields
            "created_year": "dates.created_year",
            "created_month": "dates.created_month",
            "creation_year": "dates.created_year",  # Map old name to new field
            "creation_month": "dates.created_month",  # Map old name to new field

            # Last modified date fields
            "last_modified_year": "dates.last_modified_year",
            "last_modified_month": "dates.last_modified_month"
        }

        # Build metadata filter for date fields
        metadata_filter = {}
        for key, value in date_filter.items():
            if key in date_field_mappings:
                metadata_filter[date_field_mappings[key]] = value
            else:
                # For any other fields, use direct mapping
                metadata_filter[f"dates.{key}"] = value

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                metadata_filter = {
                    "$and": [
                        metadata_filter,
                        access_filter
                    ]
                }

        # Query the vector database
        query_results = await self.chroma_manager.query_by_metadata(
            collection_name="generated_images",
            metadata_filter=metadata_filter
        )

        return query_results

    async def find_images_by_color(self, colors: List[str], user_id: Optional[str] = None):
        """Find images that contain specific colors.

        Args:
            colors: List of color hex codes or color names to search for
            user_id: Optional user ID for access control

        Returns:
            list: A list of document IDs for images with the specified colors
        """
        # Query all images
        all_images = await self.chroma_manager.query_all(
            collection_name="generated_images",
            user_id=user_id
        )

        # Filter images based on colors
        matching_images = []
        for image in all_images:
            # Apply access control check
            if self.access_control_manager and user_id:
                if not self.access_control_manager.check_access({'metadata': image.get('metadata', {})}, user_id,
                                                                "view"):
                    continue

            image_colors = image.get("metadata", {}).get("image_content", {}).get("colors", [])

            # Match if any of the specified colors are in the image colors
            if any(color.lower() in [ic.lower() for ic in image_colors] for color in colors):
                matching_images.append(image)

        return matching_images

    async def search_images_by_similarity(self, query_image=None, query_text=None, limit=10,
                                          content_filter=None, user_id=None):
        """Search for images based on visual or text similarity.

        Args:
            query_image: Optional image data or path to use as a query
            query_text: Optional text to use as a query
            limit: Maximum number of results to return
            content_filter: Optional content filters to apply
            user_id: Optional user ID for access control

        Returns:
            list: A list of image documents matching the query
        """
        if not self.image_embedder:
            raise ValueError("Image embedder is required for similarity search but not provided")

        # Generate embedding from image or text
        if query_image is not None:
            query_embedding = await self.image_embedder.embed_image(query_image)
        elif query_text is not None:
            query_embedding = await self.image_embedder.embed_text(query_text)
        else:
            raise ValueError("Either query_image or query_text must be provided")

        # Build filter
        filter_query = {}

        # Add content filters if provided
        if content_filter:
            for key, value in content_filter.items():
                if "." in key:  # Handle nested fields
                    parent, child = key.split(".", 1)
                    filter_query[f"image_content.{parent}.{child}"] = value
                else:
                    filter_query[f"image_content.{key}"] = value

        # Apply access control if user_id is provided
        if self.access_control_manager and user_id:
            access_filter = self.access_control_manager.create_access_filter(user_id)
            if access_filter:
                if filter_query:
                    filter_query = {
                        "$and": [
                            filter_query,
                            access_filter
                        ]
                    }
                else:
                    filter_query = access_filter

        # Execute the search
        search_results = await self.chroma_manager.search(
            collection_name="generated_images",
            query_embedding=query_embedding,
            where=filter_query if filter_query else None,
            limit=limit,
            include=["metadatas", "documents", "distances"]
        )

        # Process results
        results = []
        for idx, item in enumerate(search_results.get("results", [])):
            results.append({
                "id": item.get("id"),
                "metadata": item.get("metadata", {}),
                "similarity": 1.0 - (item.get("distance", 0) / 2.0),  # Convert distance to similarity score
                "rank": idx + 1
            })

        return results

    async def handle_image_search(self, query=None, parameters=None):
        """
        Handle various types of image searches based on the provided parameters.
        This is a high-level method that can be used from the SearchDispatcher.

        Args:
            query: The search query (text or image)
            parameters: Dictionary of parameters controlling the search

        Returns:
            Dictionary containing search results
        """
        if parameters is None:
            parameters = {}

        search_type = parameters.get("search_type", "text")
        user_id = parameters.get("user_id")
        limit = parameters.get("limit", 10)

        try:
            results = []

            if search_type == "model_id":
                # Search for images by model ID
                model_id = parameters.get("model_id")
                if not model_id:
                    raise ValueError("model_id is required for model_id search")

                results = await self.find_images_by_model_id(model_id, user_id)

            elif search_type == "epoch":
                # Search for images by model ID and epoch
                model_id = parameters.get("model_id")
                epoch = parameters.get("epoch")
                if not model_id:
                    raise ValueError("model_id is required for epoch search")

                results = await self.find_images_by_epoch(model_id, epoch, user_id)

            elif search_type == "highest_epoch":
                # Search for images from the highest epoch
                model_id = parameters.get("model_id")
                if not model_id:
                    raise ValueError("model_id is required for highest_epoch search")

                results = await self.find_highest_epoch_images(model_id, user_id)

            elif search_type == "content":
                # Search for images by content
                content_filter = parameters.get("content_filter", {})
                if not content_filter:
                    raise ValueError("content_filter is required for content search")

                results = await self.find_images_by_content(content_filter, user_id)

            elif search_type == "tag":
                # Search for images by tags
                tags = parameters.get("tags", [])
                require_all = parameters.get("require_all", False)
                if not tags:
                    raise ValueError("tags are required for tag search")

                results = await self.find_images_by_tag(tags, require_all, user_id)

            elif search_type == "date":
                # Search for images by date
                date_filter = parameters.get("date_filter", {})
                if not date_filter:
                    raise ValueError("date_filter is required for date search")

                results = await self.find_images_by_date(date_filter, user_id)

            elif search_type == "color":
                # Search for images by color
                colors = parameters.get("colors", [])
                if not colors:
                    raise ValueError("colors are required for color search")

                results = await self.find_images_by_color(colors, user_id)

            elif search_type == "similarity":
                # Search for images by similarity
                query_image = parameters.get("query_image")
                query_text = parameters.get("query_text", query)  # Fall back to the main query
                content_filter = parameters.get("content_filter")

                if not query_image and not query_text:
                    raise ValueError("Either query_image or query_text is required for similarity search")

                results = await self.search_images_by_similarity(
                    query_image=query_image,
                    query_text=query_text,
                    limit=limit,
                    content_filter=content_filter,
                    user_id=user_id
                )

            else:
                raise ValueError(f"Unknown search type: {search_type}")

            # Limit results if needed
            if limit and len(results) > limit:
                results = results[:limit]

            return {
                "success": True,
                "type": f"image_{search_type}_search",
                "items": results,
                "total_found": len(results)
            }

        except Exception as e:
            self.logger.error(f"Error in image search: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "type": f"image_{search_type}_search",
                "items": [],
                "total_found": 0
            }